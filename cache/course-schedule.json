{"result":{"id":"course-schedule","tag":"NeetCode150","has_article":true,"name":"Course Schedule","description":"You are given an array `prerequisites` where `prerequisites[i] = [a, b]` indicates that you **must** take course `b` first if you want to take course `a`.\n\nThe pair `[0, 1]`, indicates that must take course `1` before taking course `0`.\n\nThere are a total of `numCourses` courses you are required to take, labeled from `0` to `numCourses - 1`. \n\nReturn `true` if it is possible to finish all courses, otherwise return `false`.\n\n**Example 1:**\n\n```java\nInput: numCourses = 2, prerequisites = [[0,1]]\n\nOutput: true\n```\nExplanation: First take course 1 (no prerequisites) and then take course 0.\n\n**Example 2:**\n\n```java\nInput: numCourses = 2, prerequisites = [[0,1],[1,0]]\n\nOutput: false\n```\n\nExplanation: In order to take course 1 you must take course 0, and to take course 0 you must take course 1. So it is impossible.\n\n**Constraints:**\n* `1 <= numCourses <= 1000`\n* `0 <= prerequisites.length <= 1000`\n* All `prerequisite` pairs are **unique**.\n\n<br>\n<br>\n<details class=\"hint-accordion\">  \n    <summary>Recommended Time & Space Complexity</summary>\n    <p>\n    You should aim for a solution with <code>O(V + E)</code> time and <code>O(V + E)</code> space, where <code>V</code> is the number of courses (nodes) and <code>E</code> is the number of prerequisites (edges).\n    </p>\n</details>\n\n<br>\n<details class=\"hint-accordion\">  \n    <summary>Hint 1</summary>\n    <p>\n    Consider the problem as a graph where courses represent the nodes, and <code>prerequisite[i] = [a, b]</code> represents a directed edge from <code>a</code> to <code>b</code>. We need to determine whether the graph contains a cycle. Why? Because if there is a cycle, it is impossible to complete the courses involved in the cycle. Can you think of an algorithm to detect cycle in a graph?\n    </p>\n</details>\n\n<br>\n<details class=\"hint-accordion\">  \n    <summary>Hint 2</summary>\n    <p>\n    We can use the Depth First Search (DFS) algorithm to detect a cycle in a graph. We iterate over each course, run a DFS from that course, and first try to finish its prerequisite courses by recursively traversing through them. To detect a cycle, we initialize a hash set called <code>path</code>, which contains the nodes visited in the current DFS call. If we encounter a course that is already in the <code>path</code>, we can conclude that a cycle is detected. How would you implement it?\n    </p>\n</details>\n\n<br>\n<details class=\"hint-accordion\">  \n    <summary>Hint 3</summary>\n    <p>\n     We run a DFS starting from each course by initializing a hash set, <code>path</code>, to track the nodes in the current DFS call. At each step of the DFS, we return <code>false</code> if the current node is already in the <code>path</code>, indicating a cycle. We recursively traverse the neighbors of the current node, and if any of the neighbor DFS calls detect a cycle, we immediately return <code>false</code>. Additionally, we clear the neighbors list of a node when no cycle is found from that node to avoid revisiting those paths again.\n    </p>\n</details>","difficulty":"Medium","free":true,"test_case_type":"function","test_cases":[],"custom_test_cases":["numCourses=2\nprerequisites=[[0,1]]","numCourses=2\nprerequisites=[[0,1],[1,0]]"],"allow_customize":true,"prereqs":[{"course":"Data Structures & Algorithms for Beginners","name":"Adjacency List","routerLink":"/courses/dsa-for-beginners/31"}],"video":"## Video Explanation\n\n<div\nclass=\"video-container\"\nstyle=\"margin-top: 20px; position: relative; overflow: hidden\"\n>\n<iframe\nclass=\"video\"\nsrc=\"https://www.youtube.com/embed/EgI5nU9etnU\"\ntitle=\"Vimeo video player\"\nframeborder=\"0\"\nallow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\nallowfullscreen\n>\n</iframe>\n</div>","article_body":"## 1. Cycle Detection (DFS)\n\n::tabs-start\n\n```python\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # Map each course to its prerequisites\n        preMap = {i: [] for i in range(numCourses)}\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        # Store all courses along the current DFS path\n        visiting = set()\n\n        def dfs(crs):\n            if crs in visiting:\n                # Cycle detected\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True\n```\n\n```java\npublic class Solution {\n    // Map each course to its prerequisites\n    private Map<Integer, List<Integer>> preMap = new HashMap<>();\n    // Store all courses along the current DFS path\n    private Set<Integer> visiting = new HashSet<>();\n\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        for (int i = 0; i < numCourses; i++) {\n            preMap.put(i, new ArrayList<>());\n        }\n        for (int[] prereq : prerequisites) {\n            preMap.get(prereq[0]).add(prereq[1]);\n        }\n\n        for (int c = 0; c < numCourses; c++) {\n            if (!dfs(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean dfs(int crs) {\n        if (visiting.contains(crs)) {\n            // Cycle detected\n            return false;\n        }\n        if (preMap.get(crs).isEmpty()) {\n            return true;\n        }\n\n        visiting.add(crs);\n        for (int pre : preMap.get(crs)) {\n            if (!dfs(pre)) {\n                return false;\n            }\n        }\n        visiting.remove(crs);\n        preMap.put(crs, new ArrayList<>());\n        return true;\n    }\n}\n```\n\n```cpp\nclass Solution {\n    // Map each course to its prerequisites\n    unordered_map<int, vector<int>> preMap;\n    // Store all courses along the current DFS path\n    unordered_set<int> visiting;\n\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        for (int i = 0; i < numCourses; i++) {\n            preMap[i] = {};\n        }\n        for (const auto& prereq : prerequisites) {\n            preMap[prereq[0]].push_back(prereq[1]);\n        }\n\n        for (int c = 0; c < numCourses; c++) {\n            if (!dfs(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool dfs(int crs) {\n        if (visiting.count(crs)) {\n            // Cycle detected\n            return false;\n        }\n        if (preMap[crs].empty()) {\n            return true;\n        }\n\n        visiting.insert(crs);\n        for (int pre : preMap[crs]) {\n            if (!dfs(pre)) {\n                return false;\n            }\n        }\n        visiting.erase(crs);\n        preMap[crs].clear();\n        return true;\n    }\n};\n```\n\n```javascript\nclass Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {boolean}\n     */\n    canFinish(numCourses, prerequisites) {\n        const preMap = new Map();\n        for (let i = 0; i < numCourses; i++) {\n            preMap.set(i, []);\n        }\n        for (let [crs, pre] of prerequisites) {\n            preMap.get(crs).push(pre);\n        }\n\n        // Store all courses along the current DFS path\n        const visiting = new Set();\n\n        const dfs = (crs) => {\n            if (visiting.has(crs)) {\n                // Cycle detected\n                return false;\n            }\n            if (preMap.get(crs).length === 0) {\n                return true;\n            }\n\n            visiting.add(crs);\n            for (let pre of preMap.get(crs)) {\n                if (!dfs(pre)) {\n                    return false;\n                }\n            }\n            visiting.delete(crs);\n            preMap.set(crs, []); \n            return true;\n        }\n\n        for (let c = 0; c < numCourses; c++) {\n            if (!dfs(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n```csharp\npublic class Solution {\n    // Map each course to its prerequisites\n    private Dictionary<int, List<int>> preMap = new Dictionary<int, List<int>>();\n    // Store all courses along the current DFS path\n    private HashSet<int> visiting = new HashSet<int>();\n\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        for (int i = 0; i < numCourses; i++) {\n            preMap[i] = new List<int>();\n        }\n        foreach (var prereq in prerequisites) {\n            preMap[prereq[0]].Add(prereq[1]);\n        }\n\n        for (int c = 0; c < numCourses; c++) {\n            if (!Dfs(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private bool Dfs(int crs) {\n        if (visiting.Contains(crs)) {\n            // Cycle detected\n            return false;\n        }\n        if (preMap[crs].Count == 0) {\n            return true;\n        }\n\n        visiting.Add(crs);\n        foreach (int pre in preMap[crs]) {\n            if (!Dfs(pre)) {\n                return false;\n            }\n        }\n        visiting.Remove(crs);\n        preMap[crs].Clear();\n        return true;\n    }\n}\n```\n\n```go\nfunc canFinish(numCourses int, prerequisites [][]int) bool {\n    // Map each course to its prerequisites\n    preMap := make(map[int][]int)\n    for i := 0; i < numCourses; i++ {\n        preMap[i] = []int{}\n    }\n    for _, prereq := range prerequisites {\n        crs, pre := prereq[0], prereq[1]\n        preMap[crs] = append(preMap[crs], pre)\n    }\n\n    // Store all courses along the current DFS path\n    visiting := make(map[int]bool)\n\n    var dfs func(int) bool\n    dfs = func(crs int) bool {\n        if visiting[crs] {\n            // Cycle detected\n            return false\n        }\n        if len(preMap[crs]) == 0 {\n            return true\n        }\n\n        visiting[crs] = true\n        for _, pre := range preMap[crs] {\n            if !dfs(pre) {\n                return false\n            }\n        }\n        visiting[crs] = false\n        preMap[crs] = []int{}\n        return true\n    }\n\n    for c := 0; c < numCourses; c++ {\n        if !dfs(c) {\n            return false\n        }\n    }\n    return true\n}\n```\n\n```kotlin\nclass Solution {\n    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {\n        // Map each course to its prerequisites\n        val preMap = HashMap<Int, MutableList<Int>>()\n        for (i in 0 until numCourses) {\n            preMap[i] = mutableListOf()\n        }\n        for (prereq in prerequisites) {\n            val (crs, pre) = prereq\n            preMap[crs]!!.add(pre)\n        }\n\n        // Store all courses along the current DFS path\n        val visiting = HashSet<Int>()\n\n        fun dfs(crs: Int): Boolean {\n            if (crs in visiting) {\n                // Cycle detected\n                return false\n            }\n            if (preMap[crs]!!.isEmpty()) {\n                return true\n            }\n\n            visiting.add(crs)\n            for (pre in preMap[crs]!!) {\n                if (!dfs(pre)) {\n                    return false\n                }\n            }\n            visiting.remove(crs)\n            preMap[crs] = mutableListOf()\n            return true\n        }\n\n        for (c in 0 until numCourses) {\n            if (!dfs(c)) {\n                return false\n            }\n        }\n        return true\n    }\n}\n```\n\n```swift\nclass Solution {\n    func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {\n        // Map each course to its prerequisites\n        var preMap = [Int: [Int]]()\n        for i in 0..<numCourses {\n            preMap[i] = []\n        }\n        for pair in prerequisites {\n            preMap[pair[0]]!.append(pair[1])\n        }\n\n        // Store all courses along the current DFS path\n        var visiting = Set<Int>()\n\n        func dfs(_ crs: Int) -> Bool {\n            if visiting.contains(crs) {\n                // Cycle detected\n                return false\n            }\n            if preMap[crs]!.isEmpty {\n                return true\n            }\n\n            visiting.insert(crs)\n            for pre in preMap[crs]! {\n                if !dfs(pre) {\n                    return false\n                }\n            }\n            visiting.remove(crs)\n            preMap[crs] = []\n            return true\n        }\n\n        for c in 0..<numCourses {\n            if !dfs(c) {\n                return false\n            }\n        }\n        return true\n    }\n}\n```\n\n::tabs-end\n\n### Time & Space Complexity\n\n* Time complexity: $O(V + E)$\n* Space complexity: $O(V + E)$\n\n> Where $V$ is the number of courses and $E$ is the number of prerequisites.\n\n---\n\n## 2. Topological Sort (Kahn's Algorithm)\n\n::tabs-start\n\n```python\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        indegree = [0] * numCourses\n        adj = [[] for i in range(numCourses)]\n        for src, dst in prerequisites:\n            indegree[dst] += 1\n            adj[src].append(dst)\n\n        q = deque()\n        for n in range(numCourses):\n            if indegree[n] == 0:\n                q.append(n)\n        \n        finish = 0\n        while q:\n            node = q.popleft()\n            finish += 1\n            for nei in adj[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0:\n                    q.append(nei)\n                \n        return finish == numCourses\n```\n\n```java\npublic class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int[] pre : prerequisites) {\n            indegree[pre[1]]++;\n            adj.get(pre[0]).add(pre[1]);\n        }\n\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n\n        int finish = 0;\n        while (!q.isEmpty()) {\n            int node = q.poll();\n            finish++;\n            for (int nei : adj.get(node)) {\n                indegree[nei]--;\n                if (indegree[nei] == 0) {\n                    q.add(nei);\n                }\n            }\n        }\n\n        return finish == numCourses;\n    }\n}\n```\n\n```cpp\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<int> indegree(numCourses, 0);\n        vector<vector<int>> adj(numCourses);\n        \n        for (auto& pre : prerequisites) {\n            indegree[pre[1]]++;\n            adj[pre[0]].push_back(pre[1]);\n        }\n\n        queue<int> q;\n        for (int i = 0; i < numCourses; ++i) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        int finish = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            finish++;\n            for (int nei : adj[node]) {\n                indegree[nei]--;\n                if (indegree[nei] == 0) {\n                    q.push(nei);\n                }\n            }\n        }\n\n        return finish == numCourses;\n    }\n};\n```\n\n```javascript\nclass Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {boolean}\n     */\n    canFinish(numCourses, prerequisites) {\n        let indegree = Array(numCourses).fill(0);\n        let adj = Array.from({ length: numCourses }, () => []);\n        for (let [src, dst] of prerequisites) {\n            indegree[dst]++;\n            adj[src].push(dst);\n        }\n\n        let q = new Queue();\n        for (let i = 0; i < numCourses; i++) {\n            if (indegree[i] === 0) {\n                q.push(i);\n            }\n        }\n\n        let finish = 0;\n        while (!q.isEmpty()) {\n            let node = q.pop();\n            finish++;\n            for (let nei of adj[node]) {\n                indegree[nei]--;\n                if (indegree[nei] === 0) {\n                    q.push(nei);\n                }\n            }\n        }\n\n        return finish === numCourses;\n    }\n}\n```\n\n```csharp\npublic class Solution {\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        int[] indegree = new int[numCourses];\n        List<List<int>> adj = new List<List<int>>();\n        for (int i = 0; i < numCourses; i++) {\n            adj.Add(new List<int>());\n        }\n        foreach (var pre in prerequisites) {\n            indegree[pre[1]]++;\n            adj[pre[0]].Add(pre[1]);\n        }\n\n        Queue<int> q = new Queue<int>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) {\n                q.Enqueue(i);\n            }\n        }\n\n        int finish = 0;\n        while (q.Count > 0) {\n            int node = q.Dequeue();\n            finish++;\n            foreach (var nei in adj[node]) {\n                indegree[nei]--;\n                if (indegree[nei] == 0) {\n                    q.Enqueue(nei);\n                }\n            }\n        }\n\n        return finish == numCourses;\n    }\n}\n```\n\n```go\nfunc canFinish(numCourses int, prerequisites [][]int) bool {\n    indegree := make([]int, numCourses)\n    adj := make([][]int, numCourses)\n    for i := 0; i < numCourses; i++ {\n        adj[i] = []int{}\n    }\n\n    for _, prereq := range prerequisites {\n        src, dst := prereq[0], prereq[1]\n        indegree[dst]++\n        adj[src] = append(adj[src], dst)\n    }\n\n    q := []int{}\n    for n := 0; n < numCourses; n++ {\n        if indegree[n] == 0 {\n            q = append(q, n)\n        }\n    }\n\n    finish := 0\n    for len(q) > 0 {\n        node := q[0]\n        q = q[1:]\n        finish++\n        for _, nei := range adj[node] {\n            indegree[nei]--\n            if indegree[nei] == 0 {\n                q = append(q, nei)\n            }\n        }\n    }\n\n    return finish == numCourses\n}\n```\n\n```kotlin\nclass Solution {\n    fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {\n        val indegree = IntArray(numCourses) { 0 }\n        val adj = Array(numCourses) { mutableListOf<Int>() }\n        \n        for (prereq in prerequisites) {\n            val (src, dst) = prereq\n            indegree[dst]++\n            adj[src].add(dst)\n        }\n\n        val q: Queue<Int> = LinkedList()\n        for (n in 0 until numCourses) {\n            if (indegree[n] == 0) {\n                q.add(n)\n            }\n        }\n\n        var finish = 0\n        while (q.isNotEmpty()) {\n            val node = q.poll()\n            finish++\n            for (nei in adj[node]) {\n                indegree[nei]--\n                if (indegree[nei] == 0) {\n                    q.add(nei)\n                }\n            }\n        }\n\n        return finish == numCourses\n    }\n}\n```\n\n```swift\nclass Solution {\n    func canFinish(_ numCourses: Int, _ prerequisites: [[Int]]) -> Bool {\n        var indegree = Array(repeating: 0, count: numCourses)\n        var adj = Array(repeating: [Int](), count: numCourses)\n\n        for pair in prerequisites {\n            let src = pair[0]\n            let dst = pair[1]\n            indegree[dst] += 1\n            adj[src].append(dst)\n        }\n\n        var queue = Deque<Int>()\n        for n in 0..<numCourses {\n            if indegree[n] == 0 {\n                queue.append(n)\n            }\n        }\n\n        var finish = 0\n        while !queue.isEmpty {\n            let node = queue.popFirst()!\n            finish += 1\n            for nei in adj[node] {\n                indegree[nei] -= 1\n                if indegree[nei] == 0 {\n                    queue.append(nei)\n                }\n            }\n        }\n\n        return finish == numCourses\n    }\n}\n```\n\n::tabs-end\n\n### Time & Space Complexity\n\n* Time complexity: $O(V + E)$\n* Space complexity: $O(V + E)$\n\n> Where $V$ is the number of courses and $E$ is the number of prerequisites.","solutions":{"python":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        preMap = {i: [] for i in range(numCourses)}\n\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        visiting = set()\n\n        def dfs(crs):\n            if crs in visiting:\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True\n","javascript":"class Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {boolean}\n     */\n    canFinish(numCourses, prerequisites) {\n        const preMap = new Map();\n        const visiting = new Set();\n\n        for (let i = 0; i < numCourses; i++) {\n            preMap.set(i, []);\n        }\n\n        for (const pair of prerequisites) {\n            preMap.get(pair[0]).push(pair[1]);\n        }\n\n        for (let c = 0; c < numCourses; c++) {\n            if (!this.dfs(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {number} crs\n     * @param {Map} preMap\n     * @param {Set} visiting\n     * @return {boolean}\n     */\n    dfs(crs, preMap, visiting) {\n        if (visiting.has(crs)) {\n            return false;\n        }\n        if (preMap.get(crs).length === 0) {\n            return true;\n        }\n\n        visiting.add(crs);\n        for (const pre of preMap.get(crs)) {\n            if (!this.dfs(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting.delete(crs);\n        preMap.set(crs, []);\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> preMap(numCourses);\n        for (auto& pair : prerequisites) {\n            preMap[pair[0]].push_back(pair[1]);\n        }\n\n        vector<bool> visiting(numCourses, false);\n        for (int c = 0; c < numCourses; c++) {\n            if (!dfs(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\nprivate:\n    bool dfs(int crs, vector<vector<int>>& preMap, vector<bool>& visiting) {\n        if (visiting[crs]) {\n            return false;\n        }\n        if (preMap[crs].empty()) {\n            return true;\n        }\n\n        visiting[crs] = true;\n        for (int pre : preMap[crs]) {\n            if (!dfs(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting[crs] = false;\n        preMap[crs].clear();\n        return true;\n    }\n};\n","java":"class Solution {\n\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        HashMap<Integer, List<Integer>> preMap = new HashMap<>();\n        Set<Integer> visiting = new HashSet<>();\n\n        for (int i = 0; i < numCourses; i++) {\n            preMap.put(i, new ArrayList<>());\n        }\n\n        for (int[] pair : prerequisites) {\n            preMap.get(pair[0]).add(pair[1]);\n        }\n\n        for (int c = 0; c < numCourses; c++) {\n            if (!dfs(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean dfs(int crs, HashMap<Integer, List<Integer>> preMap, Set<Integer> visiting) {\n        if (visiting.contains(crs)) {\n            return false;\n        }\n        if (preMap.get(crs).isEmpty()) {\n            return true;\n        }\n\n        visiting.add(crs);\n        for (int pre : preMap.get(crs)) {\n            if (!dfs(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting.remove(crs);\n        preMap.put(crs, new ArrayList<>());\n        return true;\n    }\n}\n","csharp":"public class Solution {\n\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        Dictionary<int, List<int>> preMap = new Dictionary<int, List<int>>();\n        HashSet<int> visiting = new HashSet<int>();\n\n        for (int i = 0; i < numCourses; i++) {\n            preMap[i] = new List<int>();\n        }\n\n        foreach (var pair in prerequisites) {\n            preMap[pair[0]].Add(pair[1]);\n        }\n\n        for (int c = 0; c < numCourses; c++) {\n            if (!DFS(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private bool DFS(int crs, Dictionary<int, List<int>> preMap, HashSet<int> visiting) {\n        if (visiting.Contains(crs)) {\n            return false;\n        }\n        if (preMap[crs].Count == 0) {\n            return true;\n        }\n\n        visiting.Add(crs);\n        foreach (var pre in preMap[crs]) {\n            if (!DFS(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting.Remove(crs);\n        preMap[crs] = new List<int>();\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {boolean}\n     */\n    canFinish(numCourses, prerequisites) {}\n}\n","cpp":"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}\n"},"submissionCount":48553,"acceptedCount":28136}}